#!/usr/bin/env node
/**
 * Signal Helper for Enhancement Pack Agents
 * 
 * Creates and manages completion signals for multi-agent coordination.
 * Signals are stored in: enhance-05/WORK_PRODUCTS/SIGNALS/
 * 
 * @usage
 *   node scripts/signal-helper.mjs create <AGENT_ID> [options]
 *   node scripts/signal-helper.mjs check <AGENT_ID>
 *   node scripts/signal-helper.mjs list
 *   node scripts/signal-helper.mjs wait <AGENT_ID> [--timeout <seconds>]
 * 
 * @example
 *   node scripts/signal-helper.mjs create E16 --message "Task completed"
 *   node scripts/signal-helper.mjs check E15
 *   node scripts/signal-helper.mjs list
 *   node scripts/signal-helper.mjs wait E15 --timeout 60
 */

import { existsSync, readFileSync, writeFileSync, readdirSync, mkdirSync, statSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

// Get script directory and project root
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const PROJECT_ROOT = join(__dirname, '..');
const SIGNALS_DIR = join(PROJECT_ROOT, 'enhance-05', 'WORK_PRODUCTS', 'SIGNALS');

// ANSI color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  dim: '\x1b[2m',
  bold: '\x1b[1m'
};

/**
 * Print colored output to console
 */
function log(message, color = 'reset') {
  console.log(`${colors[color] || ''}${message}${colors.reset}`);
}

/**
 * Ensure signals directory exists
 */
function ensureSignalsDir() {
  if (!existsSync(SIGNALS_DIR)) {
    mkdirSync(SIGNALS_DIR, { recursive: true });
    log(`Created signals directory: ${SIGNALS_DIR}`, 'dim');
  }
}

/**
 * Get signal file path for an agent
 */
function getSignalPath(agentId) {
  const normalizedId = agentId.toUpperCase().replace(/^E/, 'E');
  return join(SIGNALS_DIR, `${normalizedId}_COMPLETE.signal`);
}

/**
 * Generate ISO timestamp
 */
function getTimestamp() {
  return new Date().toISOString();
}

/**
 * Generate signal file content
 */
function generateSignalContent(agentId, options = {}) {
  const {
    message = 'Agent task completed successfully',
    status = 'COMPLETE',
    filesCreated = [],
    filesModified = [],
    summary = ''
  } = options;

  const timestamp = getTimestamp();
  const normalizedId = agentId.toUpperCase();

  let content = `---
agent: ${normalizedId}
status: ${status}
timestamp: ${timestamp}
---

# ${normalizedId} Complete

**Agent:** ${normalizedId}
**Status:** ‚úÖ ${status}
**Timestamp:** ${timestamp}

## Summary

${message}
`;

  if (filesCreated.length > 0) {
    content += `
## Files Created

${filesCreated.map(f => `- ${f}`).join('\n')}
`;
  }

  if (filesModified.length > 0) {
    content += `
## Files Modified

${filesModified.map(f => `- ${f}`).join('\n')}
`;
  }

  if (summary) {
    content += `
## Details

${summary}
`;
  }

  content += `
---
Signal generated by: scripts/signal-helper.mjs
`;

  return content;
}

/**
 * CREATE command - Create a new signal file
 */
function createSignal(agentId, options = {}) {
  ensureSignalsDir();
  
  const signalPath = getSignalPath(agentId);
  const normalizedId = agentId.toUpperCase();

  if (existsSync(signalPath) && !options.force) {
    log(`‚ö†Ô∏è  Signal already exists for ${normalizedId}`, 'yellow');
    log(`   Use --force to overwrite`, 'dim');
    return { success: false, exists: true, path: signalPath };
  }

  const content = generateSignalContent(agentId, options);

  if (options.dryRun) {
    log(`\nüìã DRY RUN - Would create signal:`, 'cyan');
    log(`   Path: ${signalPath}`, 'dim');
    log(`\n--- Content Preview ---`, 'dim');
    console.log(content);
    log(`--- End Preview ---\n`, 'dim');
    return { success: true, dryRun: true, path: signalPath };
  }

  writeFileSync(signalPath, content, 'utf8');
  log(`‚úÖ Created signal: ${normalizedId}_COMPLETE.signal`, 'green');
  log(`   Path: ${signalPath}`, 'dim');

  return { success: true, path: signalPath };
}

/**
 * CHECK command - Check if a signal exists
 */
function checkSignal(agentId) {
  const signalPath = getSignalPath(agentId);
  const normalizedId = agentId.toUpperCase();
  const exists = existsSync(signalPath);

  if (exists) {
    const stats = statSync(signalPath);
    const content = readFileSync(signalPath, 'utf8');
    
    // Extract status from content
    const statusMatch = content.match(/status:\s*(\w+)/i);
    const status = statusMatch ? statusMatch[1] : 'UNKNOWN';

    log(`‚úÖ Signal EXISTS: ${normalizedId}`, 'green');
    log(`   Status: ${status}`, 'dim');
    log(`   Created: ${stats.mtime.toISOString()}`, 'dim');
    log(`   Path: ${signalPath}`, 'dim');

    return { exists: true, status, path: signalPath, mtime: stats.mtime };
  } else {
    log(`‚ùå Signal NOT FOUND: ${normalizedId}`, 'red');
    log(`   Expected: ${signalPath}`, 'dim');

    return { exists: false, path: signalPath };
  }
}

/**
 * LIST command - List all signals
 */
function listSignals() {
  ensureSignalsDir();

  const files = readdirSync(SIGNALS_DIR).filter(f => f.endsWith('.signal'));

  if (files.length === 0) {
    log(`\nüì≠ No signals found in ${SIGNALS_DIR}`, 'yellow');
    return { count: 0, signals: [] };
  }

  log(`\nüìã Signals Directory: ${SIGNALS_DIR}`, 'cyan');
  log(`   Found ${files.length} signal(s)\n`, 'dim');

  const signals = [];

  // Table header
  console.log(`${'Agent'.padEnd(20)} ${'Status'.padEnd(12)} ${'Created'.padEnd(24)}`);
  console.log(`${'-'.repeat(20)} ${'-'.repeat(12)} ${'-'.repeat(24)}`);

  for (const file of files.sort()) {
    const filePath = join(SIGNALS_DIR, file);
    const stats = statSync(filePath);
    const content = readFileSync(filePath, 'utf8');
    
    // Extract agent ID and status
    const agentMatch = file.match(/^(.+)_COMPLETE\.signal$/);
    const agentId = agentMatch ? agentMatch[1] : file;
    
    const statusMatch = content.match(/status:\s*(\w+)/i);
    const status = statusMatch ? statusMatch[1] : 'COMPLETE';

    const statusIcon = status === 'COMPLETE' || status === 'SUCCESS' ? '‚úÖ' : '‚è≥';
    
    console.log(`${statusIcon} ${agentId.padEnd(18)} ${status.padEnd(12)} ${stats.mtime.toISOString().slice(0, 19)}`);

    signals.push({
      agentId,
      status,
      file,
      path: filePath,
      mtime: stats.mtime
    });
  }

  console.log('');
  return { count: files.length, signals };
}

/**
 * WAIT command - Poll until a signal appears
 */
async function waitForSignal(agentId, options = {}) {
  const { timeout = 60, interval = 2 } = options;
  const signalPath = getSignalPath(agentId);
  const normalizedId = agentId.toUpperCase();

  log(`\n‚è≥ Waiting for signal: ${normalizedId}`, 'cyan');
  log(`   Timeout: ${timeout}s, Poll interval: ${interval}s`, 'dim');
  log(`   Expected: ${signalPath}\n`, 'dim');

  const startTime = Date.now();
  const timeoutMs = timeout * 1000;
  const intervalMs = interval * 1000;

  while (Date.now() - startTime < timeoutMs) {
    if (existsSync(signalPath)) {
      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
      log(`‚úÖ Signal detected: ${normalizedId} (after ${elapsed}s)`, 'green');
      return { found: true, elapsed: parseFloat(elapsed), path: signalPath };
    }

    const remaining = Math.ceil((timeoutMs - (Date.now() - startTime)) / 1000);
    process.stdout.write(`\r   Polling... ${remaining}s remaining `);

    await new Promise(resolve => setTimeout(resolve, intervalMs));
  }

  console.log(''); // New line after polling
  log(`‚ùå Timeout: Signal ${normalizedId} not found after ${timeout}s`, 'red');
  return { found: false, elapsed: timeout, path: signalPath };
}

/**
 * Print help message
 */
function printHelp() {
  console.log(`
${colors.bold}Signal Helper${colors.reset} - Multi-agent completion signal management

${colors.cyan}USAGE:${colors.reset}
  node scripts/signal-helper.mjs <command> [agent_id] [options]

${colors.cyan}COMMANDS:${colors.reset}
  ${colors.green}create${colors.reset} <AGENT_ID>   Create a completion signal
  ${colors.green}check${colors.reset}  <AGENT_ID>   Check if signal exists
  ${colors.green}list${colors.reset}               List all signals
  ${colors.green}wait${colors.reset}   <AGENT_ID>   Poll until signal appears

${colors.cyan}OPTIONS:${colors.reset}
  --message, -m <text>    Custom message for signal content
  --status, -s <status>   Status value (default: COMPLETE)
  --force, -f             Overwrite existing signal
  --dry-run, -d           Preview without creating file
  --timeout, -t <secs>    Timeout for wait command (default: 60)
  --interval, -i <secs>   Poll interval for wait (default: 2)
  --help, -h              Show this help message

${colors.cyan}EXAMPLES:${colors.reset}
  ${colors.dim}# Create a signal for agent E16${colors.reset}
  node scripts/signal-helper.mjs create E16 --message "Migration complete"

  ${colors.dim}# Check if E15 has completed${colors.reset}
  node scripts/signal-helper.mjs check E15

  ${colors.dim}# List all signals${colors.reset}
  node scripts/signal-helper.mjs list

  ${colors.dim}# Wait for E15 with 30s timeout${colors.reset}
  node scripts/signal-helper.mjs wait E15 --timeout 30

  ${colors.dim}# Dry run to preview signal content${colors.reset}
  node scripts/signal-helper.mjs create E16 --dry-run

${colors.cyan}SIGNAL FORMAT:${colors.reset}
  Signals are created at: enhance-05/WORK_PRODUCTS/SIGNALS/
  File pattern: {AGENT_ID}_COMPLETE.signal
  Content includes: agent ID, status, timestamp, summary

${colors.cyan}EXIT CODES:${colors.reset}
  0 - Success / Signal found
  1 - Error / Signal not found / Timeout
`);
}

/**
 * Parse command line arguments
 */
function parseArgs(args) {
  const parsed = {
    command: null,
    agentId: null,
    message: null,
    status: 'COMPLETE',
    force: false,
    dryRun: false,
    timeout: 60,
    interval: 2,
    help: false
  };

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];

    if (arg === '--help' || arg === '-h') {
      parsed.help = true;
    } else if (arg === '--force' || arg === '-f') {
      parsed.force = true;
    } else if (arg === '--dry-run' || arg === '-d') {
      parsed.dryRun = true;
    } else if ((arg === '--message' || arg === '-m') && args[i + 1]) {
      parsed.message = args[++i];
    } else if ((arg === '--status' || arg === '-s') && args[i + 1]) {
      parsed.status = args[++i];
    } else if ((arg === '--timeout' || arg === '-t') && args[i + 1]) {
      parsed.timeout = parseInt(args[++i], 10);
    } else if ((arg === '--interval' || arg === '-i') && args[i + 1]) {
      parsed.interval = parseInt(args[++i], 10);
    } else if (!parsed.command) {
      parsed.command = arg.toLowerCase();
    } else if (!parsed.agentId) {
      parsed.agentId = arg;
    }
  }

  return parsed;
}

/**
 * Main entry point
 */
async function main() {
  const args = process.argv.slice(2);
  const parsed = parseArgs(args);

  if (parsed.help || args.length === 0) {
    printHelp();
    process.exit(0);
  }

  const { command, agentId } = parsed;

  try {
    switch (command) {
      case 'create': {
        if (!agentId) {
          log('‚ùå Error: Agent ID required for create command', 'red');
          log('   Usage: signal-helper.mjs create <AGENT_ID>', 'dim');
          process.exit(1);
        }
        const result = createSignal(agentId, {
          message: parsed.message || `Agent ${agentId.toUpperCase()} task completed successfully`,
          status: parsed.status,
          force: parsed.force,
          dryRun: parsed.dryRun
        });
        process.exit(result.success ? 0 : 1);
        break;
      }

      case 'check': {
        if (!agentId) {
          log('‚ùå Error: Agent ID required for check command', 'red');
          log('   Usage: signal-helper.mjs check <AGENT_ID>', 'dim');
          process.exit(1);
        }
        const result = checkSignal(agentId);
        process.exit(result.exists ? 0 : 1);
        break;
      }

      case 'list': {
        listSignals();
        process.exit(0);
        break;
      }

      case 'wait': {
        if (!agentId) {
          log('‚ùå Error: Agent ID required for wait command', 'red');
          log('   Usage: signal-helper.mjs wait <AGENT_ID> [--timeout <secs>]', 'dim');
          process.exit(1);
        }
        const result = await waitForSignal(agentId, {
          timeout: parsed.timeout,
          interval: parsed.interval
        });
        process.exit(result.found ? 0 : 1);
        break;
      }

      default:
        log(`‚ùå Unknown command: ${command}`, 'red');
        log(`   Available: create, check, list, wait`, 'dim');
        printHelp();
        process.exit(1);
    }
  } catch (error) {
    log(`‚ùå Error: ${error.message}`, 'red');
    process.exit(1);
  }
}

// Run main
main();
